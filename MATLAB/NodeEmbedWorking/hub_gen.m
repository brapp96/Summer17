function [A,conf_true] = hub_gen(N,q,pH,cin,cout,chin,chout,seed)
% returns adjacency matrix and community membership vector generated by the
% hubs model with N nodes, q communities, pH fraction of hubs, intra-community
% average connectivity cin, extra-community average connectivity cout
% seed initializes the random number generator.

rng(seed);
if(mod(N,q) ~= 0)
    fprintf('Using N = %d, which is a multiple of q\n',q*floor(N/q));
end
size = floor(N/q);
N = q*size;
conf_true = zeros(N,1);
for k = 1:q
    conf_true(1+(k-1)*size:(k)*size) = k;
end
num_hubs = round(pH*size);
A = sparse(N,N);
for i = 1:q
    hub_block = sprand(size,size,chin/N);
    hub_block = triu(hub_block~=0,1);
    hub_block = hub_block + hub_block';
    A(1+(i-1)*size:i*size,1+(i-1)*size:i*size) = hub_block; % to be overwritten
    current_block = sprand(size-num_hubs,size-num_hubs,cin/N);
    current_block = (current_block ~= 0);
    current_block = triu(current_block,1);
    current_block = current_block + current_block';
    A(1+(i-1)*size+num_hubs:i*size,1+(i-1)*size+num_hubs:i*size)=current_block;
    for j = i+1:q
        hub_block = sprand(size,size,chout/N);
        hub_block = triu(hub_block~=0,1);
        hub_block = hub_block + hub_block';
        A(1+(i-1)*size:i*size,1+(j-1)*size:j*size) = hub_block; % as before
        A(1+(j-1)*size:j*size,1+(i-1)*size:i*size) = hub_block';
        current_block = sprand(size-num_hubs,size-num_hubs,cout/N);
        current_block = (current_block ~= 0);
        A(1+(i-1)*size+num_hubs:i*size,1+(j-1)*size+num_hubs:j*size) = current_block;
        A(1+(j-1)*size+num_hubs:j*size,1+(i-1)*size+num_hubs:i*size) = current_block';
    end
end
end
